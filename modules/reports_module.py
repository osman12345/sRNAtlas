"""
Reports Module for sRNAtlas
Generate comprehensive analysis reports in HTML and PDF formats
"""
import streamlit as st
import pandas as pd
import numpy as np
from pathlib import Path
from typing import Dict, Optional
from datetime import datetime
import tempfile
import base64
import io

import sys
sys.path.insert(0, str(Path(__file__).parent.parent))

from config import config


# HTML Report Template
HTML_TEMPLATE = '''
<!DOCTYPE html>
<html>
<head>
    <title>{title}</title>
    <style>
        body {{
            font-family: 'Segoe UI', Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }}
        .header {{
            background: linear-gradient(135deg, #1E88E5, #1565C0);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
        }}
        .header h1 {{
            margin: 0;
            font-size: 2em;
        }}
        .header p {{
            margin: 10px 0 0 0;
            opacity: 0.9;
        }}
        .section {{
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }}
        .section h2 {{
            color: #1E88E5;
            border-bottom: 2px solid #1E88E5;
            padding-bottom: 10px;
        }}
        .metric-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }}
        .metric {{
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }}
        .metric-value {{
            font-size: 2em;
            font-weight: bold;
            color: #1E88E5;
        }}
        .metric-label {{
            color: #666;
            font-size: 0.9em;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }}
        th, td {{
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }}
        th {{
            background: #f8f9fa;
            font-weight: 600;
        }}
        tr:hover {{
            background: #f5f5f5;
        }}
        .plot-container {{
            margin: 20px 0;
            text-align: center;
        }}
        .plot-container img {{
            max-width: 100%;
            border-radius: 8px;
        }}
        .footer {{
            text-align: center;
            color: #666;
            padding: 20px;
            font-size: 0.9em;
        }}
        .badge {{
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 600;
        }}
        .badge-up {{
            background: #e3f2fd;
            color: #1565C0;
        }}
        .badge-down {{
            background: #fce4ec;
            color: #c62828;
        }}
    </style>
</head>
<body>
    <div class="header">
        <h1>{title}</h1>
        <p>Generated on {date}</p>
        <p>sRNAtlas v{version}</p>
    </div>

    {content}

    <div class="footer">
        <p>Report generated by sRNAtlas</p>
        <p>Questions? Contact your bioinformatics team.</p>
    </div>
</body>
</html>
'''


def generate_summary_section(session_state: dict) -> str:
    """Generate summary section HTML"""
    html = '<div class="section"><h2>游늵 Analysis Summary</h2>'

    # Project info
    project_name = session_state.get('project_name', 'Unnamed Project')
    organism = session_state.get('organism', 'Unknown')

    html += f'''
    <div class="metric-grid">
        <div class="metric">
            <div class="metric-value">{project_name}</div>
            <div class="metric-label">Project Name</div>
        </div>
        <div class="metric">
            <div class="metric-value">{organism}</div>
            <div class="metric-label">Organism</div>
        </div>
    '''

    # Count matrix info
    counts = session_state.get('count_matrix') or session_state.get('annotated_counts')
    if counts is not None:
        sample_cols = counts.select_dtypes(include=[np.number]).columns.tolist()
        html += f'''
        <div class="metric">
            <div class="metric-value">{len(counts):,}</div>
            <div class="metric-label">Total Features</div>
        </div>
        <div class="metric">
            <div class="metric-value">{len(sample_cols)}</div>
            <div class="metric-label">Samples</div>
        </div>
        '''

    html += '</div></div>'
    return html


def generate_de_section(de_results: dict) -> str:
    """Generate DE results section HTML"""
    if not de_results:
        return ''

    html = '<div class="section"><h2>游댧 Differential Expression Results</h2>'

    results = de_results.get('results', {})

    for comp_name, res_df in results.items():
        padj_col = 'padj' if 'padj' in res_df.columns else 'global_FDR'
        lfc_col = 'log2FoldChange' if 'log2FoldChange' in res_df.columns else 'lfc'

        n_sig = (res_df[padj_col] < 0.05).sum()
        n_up = ((res_df[padj_col] < 0.05) & (res_df[lfc_col] > 0)).sum()
        n_down = ((res_df[padj_col] < 0.05) & (res_df[lfc_col] < 0)).sum()

        html += f'''
        <h3>{comp_name}</h3>
        <div class="metric-grid">
            <div class="metric">
                <div class="metric-value">{n_sig}</div>
                <div class="metric-label">Significant (FDR < 0.05)</div>
            </div>
            <div class="metric">
                <div class="metric-value"><span class="badge badge-up">{n_up}</span></div>
                <div class="metric-label">Up-regulated</div>
            </div>
            <div class="metric">
                <div class="metric-value"><span class="badge badge-down">{n_down}</span></div>
                <div class="metric-label">Down-regulated</div>
            </div>
        </div>
        '''

        # Top genes table
        if n_sig > 0:
            top_genes = res_df[res_df[padj_col] < 0.05].nsmallest(10, padj_col)

            html += '<h4>Top 10 Significant Genes</h4><table>'
            html += '<tr><th>Gene</th><th>Log2FC</th><th>P-value</th><th>FDR</th></tr>'

            for gene, row in top_genes.iterrows():
                pval = row.get('pvalue', row.get('pval', 'N/A'))
                html += f'''
                <tr>
                    <td>{gene}</td>
                    <td>{row[lfc_col]:.3f}</td>
                    <td>{pval:.2e}</td>
                    <td>{row[padj_col]:.2e}</td>
                </tr>
                '''
            html += '</table>'

    html += '</div>'
    return html


def generate_enrichment_section(enrichment_results: dict) -> str:
    """Generate enrichment results section HTML"""
    if not enrichment_results:
        return ''

    results = enrichment_results.get('results', {})
    if not results:
        return ''

    html = '<div class="section"><h2>游빏 Functional Enrichment</h2>'

    for source, df in results.items():
        if not isinstance(df, pd.DataFrame) or df.empty:
            continue

        term_col = next((c for c in ['name', 'Description', 'term_name'] if c in df.columns), df.columns[0])
        pval_col = next((c for c in ['p_value', 'pvalue', 'p.adjust'] if c in df.columns), None)

        html += f'<h3>{source}</h3>'
        html += f'<p>Found {len(df)} enriched terms</p>'

        # Top terms table
        if pval_col:
            top_terms = df.nsmallest(10, pval_col)
        else:
            top_terms = df.head(10)

        html += '<table><tr><th>Term</th><th>P-value</th></tr>'
        for _, row in top_terms.iterrows():
            pval = row[pval_col] if pval_col else 'N/A'
            html += f'<tr><td>{row[term_col][:60]}...</td><td>{pval:.2e}</td></tr>'
        html += '</table>'

    html += '</div>'
    return html


def generate_html_report(session_state: dict) -> str:
    """Generate complete HTML report"""
    content = ''

    # Summary section
    content += generate_summary_section(session_state)

    # DE results
    if session_state.get('de_results'):
        content += generate_de_section(session_state['de_results'])

    # Enrichment results
    if session_state.get('enrichment_results'):
        content += generate_enrichment_section(session_state['enrichment_results'])

    # Methods section
    content += '''
    <div class="section">
        <h2>游닇 Methods</h2>
        <p>This analysis was performed using the sRNAtlas, which implements
        the following workflow:</p>
        <ol>
            <li><strong>Quality Control:</strong> Read quality assessment, size distribution analysis,
            and rRNA contamination check.</li>
            <li><strong>Alignment:</strong> Reads were aligned to the reference database using Bowtie
            with parameters optimized for small RNAs.</li>
            <li><strong>Counting:</strong> Read counts were extracted from BAM files and annotated
            using RNAcentral database.</li>
            <li><strong>Differential Expression:</strong> DESeq2 was used for normalization and
            differential expression analysis with global FDR correction across all comparisons.</li>
            <li><strong>Functional Enrichment:</strong> GO and KEGG pathway enrichment analysis
            was performed using g:Profiler.</li>
        </ol>
    </div>
    '''

    # Assemble report
    report = HTML_TEMPLATE.format(
        title=f"sRNA-seq Analysis Report - {session_state.get('project_name', 'Analysis')}",
        date=datetime.now().strftime("%Y-%m-%d %H:%M"),
        version=config.version,
        content=content
    )

    return report


def render_reports_page():
    """Render the reports page"""
    st.header("游늶 Analysis Reports")

    tab1, tab2, tab3 = st.tabs([
        "游늯 Generate Report",
        "游닌 Download Data",
        "游늵 Export Figures"
    ])

    with tab1:
        render_generate_report()

    with tab2:
        render_download_data()

    with tab3:
        render_export_figures()


def render_generate_report():
    """Render report generation section"""
    st.subheader("Generate Analysis Report")

    # Report options
    st.markdown("**Include in report:**")

    col1, col2 = st.columns(2)

    with col1:
        include_summary = st.checkbox("Analysis Summary", value=True)
        include_qc = st.checkbox("QC Results", value=True)
        include_alignment = st.checkbox("Alignment Statistics", value=True)

    with col2:
        include_de = st.checkbox("DE Analysis Results", value=True)
        include_enrichment = st.checkbox("Enrichment Results", value=True)
        include_methods = st.checkbox("Methods Section", value=True)

    # Report format
    report_format = st.radio(
        "Report Format",
        options=["HTML", "PDF"],
        horizontal=True
    )

    if st.button("游늯 Generate Report", type="primary", width="stretch"):
        with st.spinner("Generating report..."):
            # Collect session state
            report_data = {
                'project_name': st.session_state.get('project_name'),
                'organism': st.session_state.get('organism'),
                'count_matrix': st.session_state.get('count_matrix'),
                'annotated_counts': st.session_state.get('annotated_counts'),
                'de_results': st.session_state.get('de_results') if include_de else None,
                'enrichment_results': st.session_state.get('enrichment_results') if include_enrichment else None,
            }

            if report_format == "HTML":
                html_report = generate_html_report(report_data)

                # Preview
                st.subheader("Report Preview")
                st.components.v1.html(html_report, height=600, scrolling=True)

                # Download
                st.download_button(
                    "游닌 Download HTML Report",
                    html_report,
                    "analysis_report.html",
                    "text/html"
                )

            else:  # PDF
                st.warning("PDF generation requires weasyprint. Install with: pip install weasyprint")

                try:
                    from weasyprint import HTML

                    html_report = generate_html_report(report_data)
                    pdf_buffer = io.BytesIO()
                    HTML(string=html_report).write_pdf(pdf_buffer)

                    st.download_button(
                        "游닌 Download PDF Report",
                        pdf_buffer.getvalue(),
                        "analysis_report.pdf",
                        "application/pdf"
                    )

                except ImportError:
                    # Fallback to HTML
                    html_report = generate_html_report(report_data)
                    st.download_button(
                        "游닌 Download HTML Report (PDF unavailable)",
                        html_report,
                        "analysis_report.html",
                        "text/html"
                    )


def render_download_data():
    """Render data download section"""
    st.subheader("Download Analysis Data")

    # Available data
    available_data = []

    if st.session_state.get('count_matrix') is not None:
        available_data.append(('count_matrix', 'Count Matrix', st.session_state.count_matrix))

    if st.session_state.get('annotated_counts') is not None:
        available_data.append(('annotated_counts', 'Annotated Counts', st.session_state.annotated_counts))

    if st.session_state.get('de_results'):
        for comp_name, df in st.session_state.de_results.get('results', {}).items():
            available_data.append((f'de_{comp_name}', f'DE Results: {comp_name}', df))

        if 'normalized_counts' in st.session_state.de_results:
            available_data.append(('normalized_counts', 'Normalized Counts',
                                   st.session_state.de_results['normalized_counts']))

    if st.session_state.get('enrichment_results'):
        for source, df in st.session_state.enrichment_results.get('results', {}).items():
            if isinstance(df, pd.DataFrame):
                available_data.append((f'enrichment_{source}', f'Enrichment: {source}', df))

    if not available_data:
        st.info("No analysis data available yet. Run analyses to generate data.")
        return

    # Display available downloads
    for data_id, data_name, data_df in available_data:
        col1, col2, col3 = st.columns([3, 1, 1])

        with col1:
            st.text(data_name)

        with col2:
            st.text(f"{len(data_df):,} rows")

        with col3:
            csv = data_df.to_csv()
            st.download_button(
                "游닌",
                csv,
                f"{data_id}.csv",
                "text/csv",
                key=f"download_{data_id}"
            )

    # Download all as ZIP
    st.divider()
    if st.button("游닌 Download All Data (ZIP)", width="stretch"):
        import zipfile

        buffer = io.BytesIO()
        with zipfile.ZipFile(buffer, 'w', zipfile.ZIP_DEFLATED) as zf:
            for data_id, data_name, data_df in available_data:
                zf.writestr(f"{data_id}.csv", data_df.to_csv())

        st.download_button(
            "游닌 Download ZIP",
            buffer.getvalue(),
            "analysis_data.zip",
            "application/zip"
        )


def render_export_figures():
    """Render figure export section"""
    st.subheader("Export Figures")

    st.info("""
    Interactive figures can be exported directly from the visualization pages:
    - Click the camera icon in the top-right of Plotly figures to download as PNG
    - Use the 'Download' buttons provided on each visualization

    For publication-quality figures, consider using the R scripts generated by the tool.
    """)

    # Quick figure generation
    st.subheader("Quick Figure Generation")

    if st.session_state.get('de_results'):
        results = st.session_state.de_results['results']

        for comp_name in results.keys():
            if st.button(f"Generate {comp_name} Volcano Plot"):
                from utils.plotting import plot_volcano

                res_df = results[comp_name]
                lfc_col = 'log2FoldChange' if 'log2FoldChange' in res_df.columns else 'lfc'
                pval_col = 'pvalue' if 'pvalue' in res_df.columns else 'pval'
                padj_col = 'padj' if 'padj' in res_df.columns else 'global_FDR'

                fig = plot_volcano(res_df, lfc_col=lfc_col, pval_col=pval_col,
                                   padj_col=padj_col, title=comp_name)
                st.plotly_chart(fig, width="stretch")

                # Export options
                col1, col2 = st.columns(2)
                with col1:
                    if st.button("Save as PNG", key=f"png_{comp_name}"):
                        fig.write_image(f"{comp_name}_volcano.png", scale=3)
                        st.success("Saved!")
                with col2:
                    if st.button("Save as SVG", key=f"svg_{comp_name}"):
                        fig.write_image(f"{comp_name}_volcano.svg")
                        st.success("Saved!")
